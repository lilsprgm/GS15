from operator import index

import  numpy as np
import bitarray
import os
import random


#Step 1 add round key : Xor with a key the file 128 bits bloc/key
def split_binary_file(filename, chunk_size=16):  # 16 bytes = 128 bits
    """
    :param filename: The path to the binary file that needs to be split.
    :param chunk_size: The size of each chunk in bytes; defaults to 16 bytes.
    :return: A list of binary chunks read from the file, each with a maximum size of `chunk_size`.
    """
    chunks = []
    try:
        with open(filename, 'rb') as f:
            chunk = f.read(chunk_size)
            while chunk:
                chunks.append(bytearray(chunk))
                chunk = f.read(chunk_size)
    except FileNotFoundError:
        print(f"Error: The file {filename} does not exist.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

    chunks[-1] += b'\x00' * (chunk_size - len(chunks[-1]))
    return chunks


def LFSR():
    """
    Generate a sequence of bits using a linear feedback shift register.

    :param length: The length of the sequence to generate.
    :return: A list of bits representing the key.
    """

    length = 16 # on met des octet donc 16*8 = 128
    lfsr = bytearray(random.randbytes(length))#at this step bits correspond to the seed, the initial state
    taps = [1,2,6]
    iteration = 10

    # Convert each character in the binary string to an integer and store in a list ([2:] to remove the 0b in that the bin fnction brings)
   # bits = [int(bit) for bit in bin(seed)[2:]]

    # Pad the list with zeros to the desired length
 #   bits = [0] * (length - len(bits)) + bits

    # Generate the sequence
    """
    for i in range(iteration):
        # Compute the new bit
        new_bit = bits[-1]
        for tap in taps:
            new_bit ^= bits[-tap]

        # Shift the register
        bits = bits[1:] + [new_bit]

    
    """
    return lfsr

def add_round_key(file_bits):
    """
    :param file_bits: The list of byte arrays to be processed where each byte is broken down into bits and XORed with a key bit sequence generated by a Linear Feedback Shift Register (LFSR).
    :return: The list of processed byte arrays with every bit encoded using XOR operation with LFSR generated key bits.
    """
    for blocks in file_bits:
        key = LFSR()
        for i in range(len(blocks)):
            blocks[i] ^= key[i]

    return file_bits



#Step 2 Substitution 32 fois Sbox 4 bits : 4 Sbox 0-7 8-16 ....

# Step 1: Create the S-Boxes as random permutations of values 0 to 15
def generate_sbox(size):
    sbox = list(range(size))  # Possible values for 4 bits (0 to 15)
    random.shuffle(sbox)    # Shuffle the values for a permutation
    return sbox




sbox1 = generate_sbox(16)
sbox2 = generate_sbox(16)
sbox3 = generate_sbox(16)
sbox4 = generate_sbox(16)
permut_matrix = generate_sbox(8)
sboxes = [sbox1, sbox2, sbox3, sbox4]



# Step 2: Substitution function
def sbox(input_block):
    """
    Apply substitution using the 4 S-Boxes on a 128-bit block
    (represented here as a list of 32 four-bit values)
    """
    for block in input_block:
        for i in range(16):
            sbox = sboxes[i // 4]       # Choose the S-Box based on the index (0-7, 8-15, 16-23, 24-31)
            left_part = (block[i] & 0xF0)>>4
            right_part = block[i] & 0x0F# Take the lower 4 bits of each element
            substituted_value_left = sbox[left_part]
            substituted_value_right = sbox[right_part]
            block[i] = substituted_value_left<<4 | substituted_value_right


    return input_block

def inv_sbox(input_block):
    for block in input_block:
        for i in range(16):
            sbox = sboxes[i // 4]       # Choose the S-Box based on the index (0-7, 8-15, 16-23, 24-31)
            left_part = (block[i] & 0xF0)>>4
            right_part = block[i] & 0x0F# Take the lower 4 bits of each element
            inv_value_left = sbox.index(left_part)
            inv_value_right = sbox.index(right_part)
            block[i] = inv_value_left<<4 | inv_value_right

    return input_block



#3

def feistel_rere(input_blocks):
    for block in input_blocks:
        left = block[0:7]
        right = block[7:16]

        for byte in left:
            byte = inv_bits_order(byte)
            byte = inv_mod257(byte+1)-1


def permutation(block):
    resultat = block
    for i in range(len(block)-1):
        resultat[i] = block[permut_matrix[i]]
    return resultat


def inv_mod257(x,mod = 257):
    """Calcule l'inverse multiplicatif de a modulo mod."""
    for i in range(mod):
        if (x * i) % mod == 1:
            return i
    return None  # Pas d'inverse multiplicatif si None

#Question : est ce qu'on utilise mod avec les entier ou dans GF256 avec le polynome x^8 +1

def inv_bits_order(byte):
    result = 0
    for i in range(8):
        result = (result << 1) | (byte & 1) #byte & 1 = LSB comme on dÃ©cale premier LSB se trouve MSB a la fin
        byte >>= 1

    return result

def trans_lineaire(input_blocks):
    for block in input_blocks:
        A=block[0:3]
        B=block[4:7]
        C=block[8:11]
        D=block[12:15]

