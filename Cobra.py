from operator import index

import  numpy as np
import bitarray
import os
import random

dev_matrix = [
        32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13,
        12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21,
        22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1
    ]

S1 = [    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
    [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
    [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
    [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
]

S2 = [15 1 8 14 6 11 3 4 9 7 2 13 12 0 5 10
  3 13 4 7 15 2 8 1412 0 1 10 6 9 11 5
  0 14 7 1110 4 13 1 5 8 12 6 9 3 2 15
  13 8 10 1 3 15 4 2 11 6 7 12 0 5 14 9]

S3 = [10 0 9 14 6 3 15 5 1 13 12 7 11 4 2 8
  13 7 0 9 3 4 6 10 2 8 5 14 12 11 15 1
  13 6 4 9 8 15 3 0 11 1 2 12 5 10 14 7
 1 10 13 0 6 9 8 7 4 15 14 3 11 5 2 12]

S4 =  [7 13 14 3 0 6 9 10 1 2 8 5 11 12 4 15
13 8 11 5 6 15 0 3 4 7 2 12 1 10 14 9
10 6 9 0 12 11 7 13 15 1 3 14 5 2 8 4
 3 15 0 6 10 1 13 8 9 4 5 11 12 7 2 14]

S5 = [ 2 12 4 1 7 10 11 6 8 5 3 15 13 0 14 9
 14 11 2 12 4 7 13 1 5 0 15 10 3 9 8 6
  4 2 1 11 10 13 7 8 15 9 12 5 6 3 0 14
 11 8 12 7 1 14 2 13 6 15 0 9 10 4 5 3]


#Step 1 add round key : Xor with a key the file 128 bits bloc/key
def split_binary_file(filename, chunk_size=16):  # 16 bytes = 128 bits
    """
    :param filename: The path to the binary file that needs to be split.
    :param chunk_size: The size of each chunk in bytes; defaults to 16 bytes.
    :return: A list of binary chunks read from the file, each with a maximum size of `chunk_size`.
    """
    chunks = []
    try:
        with open(filename, 'rb') as f:
            chunk = f.read(chunk_size)
            while chunk:
                chunks.append(chunk)
                chunk = f.read(chunk_size)
    except FileNotFoundError:
        print(f"Error: The file {filename} does not exist.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

    chunks[-1] += b'\x00' * (chunk_size - len(chunks[-1]))
    return chunks


def LFSR(length):
    """
    Generate a sequence of bits using a linear feedback shift register.

    :param length: The length of the sequence to generate.
    :return: A list of bits representing the key.
    """

    bits = [random.randint(0, 1) for i in range(length)] #at this step bits correspond to the seed, the initial state
    taps = [1,2,6]
    iteration = 10

    # Convert each character in the binary string to an integer and store in a list ([2:] to remove the 0b in that the bin fnction brings)
   # bits = [int(bit) for bit in bin(seed)[2:]]

    # Pad the list with zeros to the desired length
 #   bits = [0] * (length - len(bits)) + bits

    # Generate the sequence
    for i in range(iteration):
        # Compute the new bit
        new_bit = bits[-1]
        for tap in taps:
            new_bit ^= bits[-tap]

        # Shift the register
        bits = bits[1:] + [new_bit]

    return bits


def add_round_key(file_bits):
    """
    :param file_bits: The list of byte arrays to be processed where each byte is broken down into bits and XORed with a key bit sequence generated by a Linear Feedback Shift Register (LFSR).
    :return: The list of processed byte arrays with every bit encoded using XOR operation with LFSR generated key bits.
    """
    binary_encoded_file = []
    for blocks in file_bits:
        key = LFSR(128)
        i=0
        temp = []
        for byte in blocks:
            bits = [int(bit) for bit in bin(byte)[2:]]
            bits = [0] * (8 - len(bits)) + bits
            for bit in bits:
                temp.append(bit ^ key[i])
                i+=1
        binary_encoded_file.append(temp)

    return binary_encoded_file



#Step 2 Substitution 32 fois Sbox 4 bits : 4 Sbox 0-7 8-16 ....

def developpement(input):
    output = []
    for blocks in input :
        i=0
        temp = []
        tour = 0
        while i<len(blocks):
            temp = []
            for n in dev_matrix:
                temp.append(blocks[n+tour*32-1])
                i+=1
            tour+=1
            output.append(temp)

    return output


#def s_box(input):






